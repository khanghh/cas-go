package main

import (
	"fmt"
	"html/template"
	"os"
	"path"
	"reflect"
	"strings"
	"unicode"

	"github.com/khanghh/cas-go/model"
	"gorm.io/gen"
)

func main() {
	outPath := "./model/query"
	g := gen.NewGenerator(gen.Config{
		OutPath: outPath,
		Mode:    gen.WithDefaultQuery,
	})

	// generate from struct in project
	g.ApplyBasic(model.Models...)
	g.Execute()
	genConstants(outPath, model.Models...)
}

const constantTemplate = `
// Code generated by {{ .ScriptName }} DO NOT EDIT.

package {{ .PackageName }}

{{- range .Models }}

// Columns of {{.ModelName}}
{{- range .Fields }}
const Col{{.ModelName}}{{.FieldName}} = "{{.ColumnName}}"
{{- end }}
{{- end }}
`

func genConstants(outPath string, models ...interface{}) {
	packageName := path.Base(outPath)
	outFile := path.Join(outPath, "constants.go")

	file, err := os.Create(outFile)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	tmpl, err := template.New("constant").Parse(constantTemplate)
	if err != nil {
		fmt.Println("Error parsing template:", err)
		return
	}

	var modelsData []map[string]interface{}
	for _, model := range models {
		modelType := reflect.TypeOf(model).Elem()
		modelName := modelType.Name()

		var fields []map[string]interface{}
		for _, field := range getFields(modelType) {
			columnName := getColumnName(field)

			fieldData := map[string]interface{}{
				"ModelName":  modelName,
				"FieldName":  field.Name,
				"ColumnName": columnName,
			}
			fmt.Printf("%s:%s\n", field.Name, columnName)

			fields = append(fields, fieldData)
		}

		modelData := map[string]interface{}{
			"ModelName": modelName,
			"Fields":    fields,
		}

		modelsData = append(modelsData, modelData)
	}

	execPath, err := os.Executable()
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	data := map[string]interface{}{
		"PackageName": packageName,
		"Models":      modelsData,
		"ScriptName":  execPath,
	}

	err = tmpl.Execute(file, data)
	if err != nil {
		fmt.Println("Error executing template:", err)
		return
	}

	fmt.Println("constants.go file has been generated.")
}

func toSnakeCase(str string) string {
	var result []rune
	for i, v := range str {
		// If the current character is uppercase and not the first character
		// and the previous character is lowercase or not a letter
		if i > 0 && unicode.IsUpper(v) {
			// If the previous character is lowercase or the start of the string, add an underscore
			if unicode.IsLower(rune(str[i-1])) || !unicode.IsLetter(rune(str[i-1])) {
				result = append(result, '_')
			}
		}
		result = append(result, unicode.ToLower(v))
	}
	return string(result)
}

func getColumnName(field reflect.StructField) string {
	tag := field.Tag.Get("gorm")
	if tag != "" {
		for _, part := range strings.Split(tag, ";") {
			if strings.HasPrefix(part, "column:") {
				return strings.Trim(part[7:], "\"") // Extract column name after "column:"
			}
		}
	}
	return toSnakeCase(field.Name)
}

// Get all fields including those from embedded structs like gorm.Model
func getFields(modelType reflect.Type) []reflect.StructField {
	var fields []reflect.StructField

	// Traverse the struct fields and check for embedded structs
	for i := 0; i < modelType.NumField(); i++ {
		field := modelType.Field(i)

		// If the field is an embedded struct, retrieve its fields too
		if field.Anonymous {
			embeddedType := field.Type
			for j := 0; j < embeddedType.NumField(); j++ {
				fields = append(fields, embeddedType.Field(j))
			}
		} else {
			fields = append(fields, field)
		}
	}

	return fields
}
